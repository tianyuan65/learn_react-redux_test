{"ast":null,"code":"/*\r\n    容器组件，它不能我亲自动手写，需要借助react-redux，先下载react-redux库\r\n*/\n// 引入Count的UI组件\nimport CountUI from '../../components/Count';\n// \nimport { createIncrementAction, createDecrementAction, createIncrementAsyncAction } from '../../redux/count_action';\n\n// 引入connect用于连接UI组件与redux，connect是一个函数；connect函数调用的返回值依然是一个函数\nimport { connect } from 'react-redux';\n\n/*\r\n    1. mapStateToProps函数返回的是一个对象：\r\n    2. 返回的对象中的key就作为传递给UI组件props的key，value就作为传递给UI组件props的value\r\n    3. mapStateToProps用于传递状态\r\n*/\n// react-redux帮我调用mapStateToProps函数的时候，已经帮我把状态传过去了，只需要将redux里保存着的状态(state)作为参数传进a函数中，并传递给UI组件即可\nfunction mapStateToProps(state) {\n  return {\n    count: state\n  };\n}\n\n/*\r\n    1. mapDispacthToProps函数返回的是一个对象：\r\n    2. 返回的对象中的key就作为传递给UI组件props的key，value就作为传递给UI组件props的value\r\n    3. mapDispacthToProps用于传递操作状态的方法\r\n*/\nfunction mapDispacthToProps(dispatch) {\n  // UI组件只要调用jia函数，就会接收到number(它是要加的那个数字)，然后就会通知redux传递action对象(也就是type和data的值)\n  return {\n    // 通知redux执行加法\n    jia: number => dispatch(createIncrementAction(number)),\n    // 通知redux执行减法\n    jian: number => dispatch(createDecrementAction(number)),\n    // 通知redux执行异步任务\n    jiaAsync: number => dispatch(createIncrementAsyncAction(number))\n  };\n}\n\n// 使用connect()()，创建并暴露一个Count容器组件，connect函数再一次调用时，就可以接到容器组件(CountContainer)，传入Count的UI组件作为参数，就会把UI组件和容器组件联系起来(这是固定写法)\n// connect在第一次调用时需要传入两个参数，且这两个参数必须都是函数，作用就是传递状态\nexport default connect(mapStateToProps, mapDispacthToProps)(CountUI);","map":{"version":3,"names":["CountUI","createIncrementAction","createDecrementAction","createIncrementAsyncAction","connect","mapStateToProps","state","count","mapDispacthToProps","dispatch","jia","number","jian","jiaAsync"],"sources":["C:/Users/田园/Desktop/redux_test/src/containers/Count/index.jsx"],"sourcesContent":["/*\r\n    容器组件，它不能我亲自动手写，需要借助react-redux，先下载react-redux库\r\n*/\r\n// 引入Count的UI组件\r\nimport CountUI from '../../components/Count'\r\n// \r\nimport {createIncrementAction,createDecrementAction,createIncrementAsyncAction} from '../../redux/count_action'\r\n\r\n// 引入connect用于连接UI组件与redux，connect是一个函数；connect函数调用的返回值依然是一个函数\r\nimport {connect} from 'react-redux'\r\n\r\n/*\r\n    1. mapStateToProps函数返回的是一个对象：\r\n    2. 返回的对象中的key就作为传递给UI组件props的key，value就作为传递给UI组件props的value\r\n    3. mapStateToProps用于传递状态\r\n*/\r\n// react-redux帮我调用mapStateToProps函数的时候，已经帮我把状态传过去了，只需要将redux里保存着的状态(state)作为参数传进a函数中，并传递给UI组件即可\r\nfunction mapStateToProps(state) {\r\n    return {count:state}\r\n}\r\n\r\n/*\r\n    1. mapDispacthToProps函数返回的是一个对象：\r\n    2. 返回的对象中的key就作为传递给UI组件props的key，value就作为传递给UI组件props的value\r\n    3. mapDispacthToProps用于传递操作状态的方法\r\n*/\r\nfunction mapDispacthToProps(dispatch) {\r\n    // UI组件只要调用jia函数，就会接收到number(它是要加的那个数字)，然后就会通知redux传递action对象(也就是type和data的值)\r\n    return {\r\n        // 通知redux执行加法\r\n        jia:number=>dispatch(createIncrementAction(number)),\r\n        // 通知redux执行减法\r\n        jian:number=>dispatch(createDecrementAction(number)),\r\n        // 通知redux执行异步任务\r\n        jiaAsync:number=>dispatch(createIncrementAsyncAction(number))\r\n    }\r\n}\r\n\r\n\r\n// 使用connect()()，创建并暴露一个Count容器组件，connect函数再一次调用时，就可以接到容器组件(CountContainer)，传入Count的UI组件作为参数，就会把UI组件和容器组件联系起来(这是固定写法)\r\n// connect在第一次调用时需要传入两个参数，且这两个参数必须都是函数，作用就是传递状态\r\nexport default connect(mapStateToProps,mapDispacthToProps)(CountUI)\r\n\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAOA,OAAO,MAAM,wBAAwB;AAC5C;AACA,SAAQC,qBAAqB,EAACC,qBAAqB,EAACC,0BAA0B,QAAO,0BAA0B;;AAE/G;AACA,SAAQC,OAAO,QAAO,aAAa;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,KAAK,EAAE;EAC5B,OAAO;IAACC,KAAK,EAACD;EAAK,CAAC;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASE,kBAAkBA,CAACC,QAAQ,EAAE;EAClC;EACA,OAAO;IACH;IACAC,GAAG,EAACC,MAAM,IAAEF,QAAQ,CAACR,qBAAqB,CAACU,MAAM,CAAC,CAAC;IACnD;IACAC,IAAI,EAACD,MAAM,IAAEF,QAAQ,CAACP,qBAAqB,CAACS,MAAM,CAAC,CAAC;IACpD;IACAE,QAAQ,EAACF,MAAM,IAAEF,QAAQ,CAACN,0BAA0B,CAACQ,MAAM,CAAC;EAChE,CAAC;AACL;;AAGA;AACA;AACA,eAAeP,OAAO,CAACC,eAAe,EAACG,kBAAkB,CAAC,CAACR,OAAO,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}